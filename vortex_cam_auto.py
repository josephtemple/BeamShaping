"""
vortex_cam_auto.py

Image the vortex beam mode generated by SLM for different central positions of the hologram.
Uses slm_ui.py to set beam/SLM parameters and the range of central positions, then takes
pictures of each (averaging across 5 frames) and saves them to a .npz file in /data/.

The .npz file can be loaded with data = np.load("PATH/data/beam_dataset.npz"), and the images,
list of corresponding x-offsets, and list of corresponding y-offsets are then data['frames'],
data['x_offset_arr'] and data['y_offset_arr'] respectively. To find a particular frame,
we recommend:
idx = np.where((x_offset_arr == target_x) & (y_offset_arr == target_y))[0][0]
frame = data['frames'][idx]

"""

import numpy as np
import os
from sys import exit
from datetime import datetime

import cv2
from screeninfo import get_monitors
from pylablib.devices import uc480

import tkinter as tk
from slm_ui import SLMControlsUI

# Setup monitors and matrices related to screen size
monitors = get_monitors()
if len(monitors) > 1:
    slm_monitor = monitors[1]
    print("[vortex_cam_auto.py] Secondary monitor set as SLM display.")
else:
    slm_monitor = monitors[0]
    print("[vortex_cam_auto.py][DEBUG] SLM not detected. Will display SLM in secondary window on primary monitor.")

H = slm_monitor.width
V = slm_monitor.height

x = np.arange(-H/2, H/2)
y = np.arange(-V/2, V/2)
X, Y = np.meshgrid(x, y)

# Create SLM window
slm_window_name = 'SLM'
if len(monitors) > 1:
    cv2.namedWindow(slm_window_name, cv2.WND_PROP_FULLSCREEN)
    cv2.moveWindow(slm_window_name, slm_monitor.x, slm_monitor.y)
    cv2.setWindowProperty(slm_window_name, cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)
else:
    cv2.namedWindow(slm_window_name, cv2.WINDOW_NORMAL)
    cv2.resizeWindow(slm_window_name, 1200, 900)

# Instantiate camera object, set it to collect grayscale
cam = uc480.UC480Camera()     
cam.set_color_mode("raw8")

# Function to set SLM based on given offset and pre-set variables
def set_slm(x_0, y_0, vals = None):
    """
    Compute hologram and display in SLM window; auto-called by Tkinter.
    Takes optional argument of beam parameter dictionary
    """
    if vals:
        l, nx, ny = vals["l"], vals["nx"], vals["ny"]
    phi = np.angle((X - x_0) + 1j * (Y - y_0))
    gx = nx / H
    gy = ny / V
    hologram = np.mod(l * phi + 2 * np.pi * (Y * gy + X * gx), 2 * np.pi)
    scaled = (hologram / hologram.max() * 255).astype(np.uint8)

    cv2.imshow(slm_window_name, scaled)
    cv2.waitKey(20)

# Create control window and unpack values after pressing "GATHER" button
root = tk.Tk()
ui = SLMControlsUI(root, cam=cam, set_slm_func=set_slm)
root.mainloop()
if hasattr(ui, "values"):
    values = ui.values
    # continue with data gathering
else:
    print("[vortex_cam_auto.py] Quitting...")
    exit(0)

# Loop to set SLM, take picture, store resultant 8bit grayscale image
x_offset_arr = np.arange(values["x_start"], values["x_stop"] + values["x_step"], values["x_step"])
y_offset_arr = np.arange(values["y_start"], values["y_stop"] + values["y_step"], values["y_step"])

def image_avg(num_frames_to_avg = 5):
    '''
    Take an image using the camera, averaging over five frames to minimize noise
    '''
    frames_to_avg = []
    _ = cam.grab()[0]     # discard first img grab as camera auto-adjusts
    for _ in range(num_frames_to_avg):
        frame = cam.grab()[0]  # 2D array
        frames_to_avg.append(frame)
    # average frames, and ensure result is a 2D array of 8bit ints
    avg_frame = np.mean(np.stack(frames_to_avg, axis=0), axis=0)
    avg_frame = np.round(avg_frame).astype(np.uint8)
    return avg_frame

img_list = []
x_list = []
y_list = []
for x_off in x_offset_arr:
    for y_off in y_offset_arr:
        set_slm(x_off, y_off, values) # Set the SLM to be centered at (x_off, y_off)

        img = image_avg()

        # add to dataset
        img_list.append(img)
        x_list.append(x_off)
        y_list.append(y_off)

        print(f"[vortex_cam_auto] Image captured for x_off = {x_off}, y_off = {y_off}")

# convert lists to numpy arrays
frames = np.stack(img_list, axis=0)   # shape (N, H, W)
x_offsets = np.array(x_list)
y_offsets = np.array(y_list)

# save all together in one .npz
script_dir = os.path.dirname(os.path.abspath(__file__))
data_dir = os.path.join(script_dir, "data")
os.makedirs(data_dir, exist_ok=True)
timestamp = datetime.now().strftime("%Y%m%d_%H%M")
filename = f"vortex_{timestamp}.npz"
np.savez(f"{data_dir}/{filename}", frames=frames, x_offset_arr = x_offsets, y_offset_arr = y_offsets)

cam.close()
cv2.destroyAllWindows()